1.类加载过程与java内存模型
	1）加载
		a.根据类的全限定名获取二进制字节流
		b.将字节流代表的静态存储结构转换为【方法区】的运行时数据结构
		c.在方法区中为类生成java.lang.Class对象，作为方法区此类的访问入口
	2）验证
		a.文件格式验证  符合class文件规范，并可以被虚拟机处理
		b.元数据验证  符合java语法规范
		c.字节码验证  
		d.符号引用验证
	3）准备  为类变量分配内存并赋初始值，类变量使用的内存在【方法区】上。
			注意：a.static修饰的为类变量，初始值并不是代码中定义的值。
				  b.final修饰的变量，会被赋上代码中定义的值，且不会引起初始化。
		    八种基本数据类型的初始值
			byte  1字节  8位  初始值0  可表示 -128~127  （2的8次方）
			short  2     16      0
			int    4     32      0
			long   8     64      0
			float  4     32      0.0
			double 8     64      0.0
			char   2     16      空      0~65535
			boolean1     8       false   true或false
	4）解析  将符号引用转换为直接引用的过程
		符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，
			只要使用时能无歧义地定位到目标即可。
		直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
		a.类或接口的解析
			如果当前类无权访问定义的类或接口，则抛出IllegalAccessError
		b.字段解析
			解析顺序：当前类->父类或接口  
			如果所有位置未找到对应的字段，则抛出NoSuchFieldError
		c.类方法的解析
			解析顺序：当前类->父类或接口
			如果在接口中找到匹配的方法，则抛出AbstractMethodError
			如果未找到对应的方法，则抛出NoSuchMethodError
		d.接口方法解析
	5）初始化
		为变量赋值
		
	参见：https://blog.csdn.net/u010942465/article/details/81709246
		

2.YGC与FullGC触发条件
	

3.频繁YGC，如何排查

4.类加载时机
	1）new,putStatic,getStatic,invokeStatic
	   初始化对象，设置/获取静态字段（没有被final修饰），调用静态方法。
	2）反射
	3）初始化子类时，发现父类未初始化
	4）虚拟机启动时，对包含有main方法的主类初始化
	5）使用动态语言时，解析为REF_putStatic,REF_getStatic,REF_invokeStatic句柄，且类没有初始化
	
	被动引用：
	
	
JVM课程学习
第一章
002
1.JVM整体运行原理
	.java文件编译成.class文件
	类加载器将.class文件中的类加载到JVM中

003
2.JVM在什么情况下会加载一个类？（.class字节码文件中加载到JVM）
	代码中使用到时
	main方法的主类，以及main方法内使用的类
3.类加载器和双亲委派机制
	1)启动类加载器 BootstrapClassLoader
		加载java目录下的核心类，lib目录
	2）扩展类加载器	ExtensionClassLoader
		lib\ext目录
	3）应用程序类加载器 ApplicationClassLoader
		classPath环境变量指定的路径中的类
	4）自定义类加载器	
		
	5）双亲委派机制
		避免多层级加载器重复加载某些类
		tomcat打破了双亲委派机制
4.如何对“.class”文件处理，保证不被人拿到后反编译获取公司源代码？
	1）编译时，对字节码加密；
	2）使用自定义类加载器解密文件

004
5.java内存区域
	1）存放类信息，静态变量的方法区（1.8之前叫方法区，1.8之后叫Metaspace元数据空间）
	2）程序计数器
	3）存放局部变量表的虚拟机栈
	4）存放对象的堆
	5）执行本地方法的本地方法栈
	6）堆外内存（非JVM内存区域）

005
6.方法执行完之后会怎样?
	方法执行时，虚拟机栈中会产生大量栈帧信息，随着方法执行会逐步出栈；
	但是堆内存中的对象还是占用内存空间的，这些对象的积累会造成内存空间不足；
	因此需要JVM垃圾回收机制
7.对象在堆内存中占用多少内存空间
	1）对象本身的信息
	2）对象实例变量作为数据占用的空间

第二章
008
8.对象生存周期
	1）被局部变量引用的对象，在局部变量出栈后，就可以被垃圾回收掉
	2）对类变量引用的对象，将长期停留在堆内存中
9.新生代与老年代
	被虚拟机栈中局部变量引用，出栈就被回收的对象放在新生代；
	被静态变量引用，需要长期生存的放在老年代。（优先分配在新生代）
		对于不同生存周期的对象，需要使用不同的垃圾回收策略，
		因此区分新生代与老年代来使用不同的垃圾回收策略。
10.永久代
	方法区就是永久代，和堆内存一样，都是线程共享的内存区域。
		存放已被JVM加载的类信息，即时编译后的代码，静态变量和常量等
	方法区无法满足内存分配需求时，会抛出OutOfMemoryError异常。
11.方法区会不会进行垃圾回收 
	会，方法区垃圾回收和堆内存相比，回收效率极低。但仍可以进行垃圾回收。
	垃圾回收的主要对象为：废弃常量和无用类
	满足如下三个条件：(实例对象，类加载器被回收，类对象无引用)
	1）该类的所有实例对象对已经被回收
	2）加载该类的ClassLoader已经被回收
	3）对该类的Class对象没有任何引用，无法在任何地方通过反射访问该类的方法。

009
12.新生代垃圾回收的时机（Minor GC 或 Young GC）
	分配新对象时，发现新生代内存空间不足，就会触发一次垃圾回收。
	第一次：Eden区空间不足
	之后：Eden+其中一个survivor空间不足
13.老年代对象的由来--（见19）
	当新生代对象经过了15次垃圾回收，仍然存活的时候，就会被转移到老年代中。

010
14.JVM核心参数
	-Xms：堆内存大小
	-Xmx：最大堆内存大小
	-Xmn：新生代大小
	-XX:PermSize: 永久代大小    1.8之后叫  -XX:MetaspaceSize
	-XX:MaxPermSize:最大永久代大小   -XX:MaxMetaspaceSize
	-Xss：每个线程的栈内存大小
	
	例：-Xms512M -Xmx512M -Xss1M -Xmn128M -XX:MaxPermSize=128M   (注意等号)
	启动jar包  java -Xms512M -Xmx512M -Xss1M -Xmn128M -XX:MaxPermSize=128M -jar App.jar
	
第三章
015
15.哪些对象不会被回收？
	可达性分析算法
	GC roots：局部变量，静态变量可以作为GC roots
		1）被局部变量引用的对象
		2）被静态变量引用的对象
16.引用类型
	强引用，软引用，弱引用，虚引用
	强引用： 变量 = new对象  不会被垃圾回收
	软引用：new SoftReference<对象>  使用softReference包裹，  垃圾回收后内存仍然不够时，会被回收
	弱引用：new WeakReference<对象>  会被回收
	虚引用:PhantomReference

016
17.新生代区域划分
	Eden区和两个survivor区  80%和10%，10%
18.新生代垃圾回收算法
	复制算法
	新生对象都放在Eden区，当Eden区空间不足时进行垃圾回收；
	使用复制算法，将存活对象放入其中一个Survivor区，将Eden清空；
	当Eden第二次进行垃圾回收时，将Eden和上次存放存活对象的survivor区内的存活对象都复制到另一块survivor区
	
	好处：只有10%的空间空闲，90%的空间都被使用。
	
017
19.什么对象会进入老年代
	1）经过15次Minor GC仍然存活的对象 
		-XX:MaxTenuringThreshold  可配置
	2）动态年龄判断-规则：年龄1+年龄2+……+年龄n所占用内存大于survivor区50%时，年龄大于n的对象直接进入老年代
	3）大对象直接进入老年代
		-XX:PretenureSizeThreshold 配置大对象的大小
	4）Minor GC存活的对象超过了survivor区大小，则直接进入老年代
20.老年代空间分配担保规则
	开启：-XX:+HandlePromotionFailure  （1.6之后被废弃）
	关闭：-XX:-HandlePromotionFailure
	1）Minor GC时，老年代会进行一次判断，判断老年代剩余空间是否大于新生代对象大小；
	2）如果小于新生代对象大小，则先检查配置 -XX:+HandlePromotionFailure;
		a.如果有此配置，判断老年代剩余空间是否大于历次Minor GC进入老年代的平均大小；
			如果大于平均大小，则进行Minor GC;
				Minor GC后：-存活对象小于Survivor，放入Survivor区；
							-存活对象大于Survivor，小于老年代剩余空间，放入老年代；
							-存活对象大于Survivor，大于老年代剩余空间，
								则发生 Handle Promotion Failure情况，进行Full GC；
			如果小于平均大小，则Full GC;
		b.如果没有此配置，则直接进行Full GC，腾出空间后执行Minor GC;
		
		1.6之后被废弃：
		老年代剩余空间大于新生代对象大小
		或老年代剩余空间大于历次Minor GC进入老年代对象的平均大小
		即可进行Minor GC。
21.Full GC触发时机 
	1）Minor GC发生前，未配置空间分配担保策略，年轻代对象大小大于老年代剩余空间；
	2）Minor GC发生前，开启了空间担保策略，但是新生代对象大于历次Minor GC移入老年代的平均对象大小；
	3）Minor GC发生后，存活对象大小大于老年代剩余空间大小。
	4）如果使用的是CMS垃圾回收器，-XX:CMSInitiatingOccupancyFaction
		当老年代达到如上配置的阈值时，会自动触发Full GC。  （--024节补充）
22.老年代垃圾回收算法
	标记清理算法
	1）标记存活对象
	2）移动存活对象，避免内存碎片
	3）将垃圾对象清空
	
018
23.新生代内存分配
	默认值 -XX:SurvivorRatio=8  表示Eden占80%
	可根据实际情况调整大小，降低Eden比例，增加Survivor空间，
		可防止Minor GC时存活的的对象直接进入老年代，造成频繁Full GC。
24.垃圾回收期简介
	Serial和SerialOld：单线程垃圾收集器
		分别用来回收新生代和老年代的垃圾对象。
	ParNew和CMS：多线程垃圾收集器
		分别收集新生代和老年代的垃圾对象。
	G1：统一收集新生代和老年代

019
25.新生代垃圾回收流程
	1.当Eden区满时，会启动一个垃圾回收线程，使用垃圾回收器，运用垃圾回收算法（复制算法），
		将Eden区的存活对象标记出来，复制到Survivor1区，然后将Eden区垃圾对象清空。
	2.当Eden区再次满时，依然如上步骤，将Eden和Survivor1区的存活对象标记出来，复制到Survivor2中，
		并清空Eden和Survivor1区。
26.stop the world
	GC时，会停止java系统的所有线程
27.新生代老年代比例
	1:2  -XX:NewRatio=2  老年代/新生代

第四章
022
28.配置JVM的位置
	catalina.sh
29.多线程垃圾收集器好，还是单线程垃圾收集器
	区别对待：如果运行在多核CPU的机器上，多线程更好，可以充分利用CPU，更快的进行垃圾收集；
		如果运行在单核CPU上，单线程更好，可以避免单核CPU运行多个线程造成的频繁上下文切换。
30.服务器模式和客户端模式
	-server 服务器模式
	-client 客户端模式
	运行在多核CPU的Linux服务器上，多是服务器模式的；建议采用ParNew作为新生代垃圾回收器
	客户端模式，大都运行在Windows上，采用单核CPU，
		如百度网盘等客户端；建议采用Serial最为新生代垃圾回收器

023
31.CMS垃圾收集器基本原理-老年代垃圾收集器
	标记-清理算法
	缺点：造成很多内存碎片  （--见024）
32.CMS垃圾收集器执行流程
	1）初始标记  stop the world 
		只标记GC roots直接引用的对象
			（GC roots：方法的局部变量，静态变量）
	2）并发标记  最耗时，但是并发进行
		可达性分析-逐步判断对象是否被GC roots引用
		并发标记过程中，仍然会产生很多垃圾对象
	3）重新标记  stop the world
		对第二阶段中产生的垃圾对象进行标记
	4）并发清理  并发进行
		清理掉垃圾对象
	最耗时的部分是：并发标记-需要对所有初始标记未被标记的对象进行标记
					并发清理-需要对所有标记为垃圾的对象进行清理
			但是都是并发进行的，因此对系统影响并不大。
			
024
33.CMS存在的问题
	1.造成CPU资源紧张
		并发标记和并发清理时，默认的垃圾回收线程为（CPU核数+3）/4
		例：2核CPU，CMS会启动 （2+3）/4 = 1个线程回收垃圾
	2.Concurrent mode failure问题
		浮动垃圾：并发清理阶段，仍然会有对象进入老年代，并在短时间内成为垃圾对象
			而这些垃圾对象未被标记，需要等下次Full GC才会被回收。
		如果CMS期间，进入老年代的对象大于了所剩空间，则会发生Concurrent Mode Failure问题，
			此时会自动用 Serial Old 垃圾收集器代替CMS，强行stop the world，不再产生新的对象
			使用单线程继续回收垃圾对象。	
			
		为了保证CMS垃圾回收期间，还有足够的空间可以让一些对象进入老年代，
			老年代会预留一部分空间，即老年代达到某个阈值时也会自动触发CMS。（触发Full GC）
			-XX:CMSInitiatingOccupancyFaction 配置阈值，1.6默认为92%

	3.内存碎片问题
		并发清理会产生很多碎片，因此Full GC后会有内存碎片整理。
		-XX:+UseCMSCompactAtFullCollection 默认打开  表示会CMS会进行内存碎片整理。
		-XX:CMSFullGCsBeforeCompact  默认为0， 表示每次Full GC后都会进行碎片整理
	
	因此完整的CMS流程为：
		初始标记-并发标记-重新标记-并发清理---[启用Serial Old，stop the world]-碎片整理
	
	CMS垃圾回收器参数配置：
	-XX:CMSInitiatingOccupancyFaction=92  老年代达到多大空间占用时，自动触发Full GC 
	-XX:+UseCMSCompactAtFullCollection  Full GC之后是否进行碎片整理  默认开启
	-XX:CMSFullGCsBeforeCompact=0  多少次Full GC之后进行碎片整理  默认0，即每次

025
34.总结一次电商订单系统的JVM配置
	下单高峰期，一秒钟300个订单，产生60M对象，并瞬间成为垃圾对象
	
	使用4核8G服务器，分配给JVM内存空间为4G，堆内存可以是3G
	-Xms3072M -Xmx3072M
	方法区256M
	-XX:PermSize=256M -XX:MaxPermSize=256M
	栈空间大小1M
	-Xss1M
	分析可得高并发情况下，会在短时间内产生大量对象，并在短时间内迅速变为垃圾对象。
		因此较短时间内就会造成新生代空间不足，导致Minor GC
		考虑到对象存活的时间周期都较短，大部分不可能经过15次Minor GC之后仍然存活，
		即通过此方法进入老年代可能性较低，因此需要保证有足够的survivor空间，
		以防Minor GC后存活对象大于survivor区大小，或在survivor对象大于空间50%，而直接进入老年代。
		根据如上特点分析，可以将老年代设置小空间，增大survivor。
	-Xmn2048 -XX:SurvivorRatio=8
	对象活过几次Minor GC进入老年代：
		以本案例来看，由于大部分对象是迅速死亡，经过15次仍然存活的只能是类似@Controller等类对象，
		因此可以设置更小的阈值，让此类对象尽快进入老年代，而不占用新生代空间。
	-XX:MaxTenuringThreshold=5
	大对象直接进入老年代：
	-XX:PretenureSizeThreshold=1M
	使用parNew和CMS垃圾回收器
	-XX:+UseParNewGC
	-XX:+UseConcMarkSweepGC
	
	-Xms3072M -Xmx3072M -Xmn2048M -XX:SurvivorRatio=8 -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M
	-XX:PretenureSizeThreshold=1M -XX:MaxTenuringThreshold=5
	-XX:+UseParNewGC -XX:+UseConcMarkSweepGC
	
	总结：
		如果对象会迅速创建，并迅速死亡，老年代可以设置小空间，增大survivor区大小，
			减小进入老年代的年龄限制。


第五章
029
35.G1垃圾收集器概述
	1）将内存区域划分为多个大小相等的Region
	2）可设置垃圾回收预期停顿时长  -XX:MaxGCPauseMills  最大停顿时长，默认为200ms
		回收价值：以最少的时间，回收最多的空间

030
36.内存中有多少个Region，每个Region有多大
	依然使用-Xms -Xmx设置内存大小
	-XX:UseG1GC  使用G1垃圾回收器
	默认有2048个Region（最多），Region大小=堆内存大小/2048
	每个Region必须是2的倍数
	-XX:G1HeapRegionSize  设置Region大小
37.G1区域划分
	初始新生代占比为 5%  -XX:G1NewSizePercent=5%
	系统运行过程，新生代的Region会增多，最多不会超过60%
	-XX:G1MaxNewSizePercent  设置新生代最多的Region比例
	垃圾回收时，新生代Region还会减少，Region属于新生代还是老年代是动态的。
	
	新生代划分：
	-XX:SurvivorRatio=8  设置Eden和Survivor的比例，默认8:1:1
	
	新生代Region空间达到预设的60%时，就会触发Minor GC
		也同样需要“stop the world”，采用复制算法，将存活对象由Eden的Region，转移到Survivor的Region。
38.对象什么时候进入老年代
	1）-XX:MaxTenuringThreshold  设置最大存活年龄  达到这个年龄进入老年代
	2）动态年龄判断  存活对象超过survivor50%时，超龄的对象进入老年代
39.大对象Region
	默认超过Region空间50%大小的对象，成为大对象，大对象进入大对象Region
	并跟随新生代，老年代回收时，一并回收大对象。
	
	
	
	
	

  
	
	
	
	


	