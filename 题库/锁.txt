1.乐观锁与悲观锁？实现？应用场景

2.synchronized的原理，jdk6对synchronized的优化
	
	一、作用
		1.原子性  确保线程互斥的访问同步代码
		2.可见性  保证共享变量的修改可以及时可见   java内存模型：工作内存-主内存
		3.有序性  一个解锁操作发生在下一个加锁操作之前
	二、用法
		synchronized可以把任意一个非null对象作为“锁”，jvm中叫对象监视器（Object Minoter）
		1.作用于方法上    锁定的是实例对象
		2.作用于静态方法上   锁定的是类对象
		3.作用于代码块上   锁定的是实例对象
	三、特性
		1、对象锁  作用于对象上 ，可实现对临界资源的同步互斥访问
		2、排它锁
		3、可重入性  线程持有锁之后，可同步访问同一对象或父类对象的同步方法，无需再获取锁
	四、同步原理
		1）同步代码块的同步
			JVM内置锁，通过内部对象Monitor（监视器锁）实现。
			对象监视器（Object Monitor）
			monitorenter：尝试获取monitor所有权
				1.如果monitor进入数为0，则进入monitor，将monitor进入者设置为1，成为monitor的owner；
				2.如果线程已经进入了monitor，只是重新进入，则进入者+1；（可重入）
				3.如果其他线程已经占用了monitor，则进入阻塞状态。
			
			monitorexit：退出monitor
				monitor进入数-1，如果为0，则释放monitor的所有权
		
		2）同步方法的同步
			ACC_SYNCHRONIZED 标志位
			线程执行方法时，会检查方法的ACC_SYNCHRONIZED标识是否被设置，如果被设置了，
				执行线程会先获取monitor，在执行方法体，执行完之后释放monitor。
				
		Monitor记录的信息：
			count：进入Monitor的数量
			_EntryList:处于Blocking状态的线程
			_WaitingList:处于排队状态的线程
			_owner:当前所对象的拥有者
			1、当多个线程同时访问一段同步代码时，进入_EntryList集合，获取到Monitor的线程，
				进入_Owner区域,并把当前Monitor的owner设置为当前线程，count数+1；
			2、如果调用了wait方法，释放当前Monitor，owner为null，count-1，
				进入waitList并等待被唤醒；
			3、线程执行完毕，则释放Monitor，恢复count
		Monitor会在对象头里的Mark Word中被引用指向。
		
	五、synchronized的优化  （jdk1.6之后）
		锁主要存在四种状态：无锁、偏向锁、轻量级锁、重量级锁
			升级是单向的，不会出现锁的降级。
			jdk1.6中默认是开启偏向锁和轻量级锁的，可以使用-XX:-UseBiasedLocking禁用偏向锁。
		
		1）自旋锁
			使用原因：
				大部分的临界区是很小的，占用的时间很短，如果频繁的阻塞和唤醒，代价太大，因此引入自旋锁。
			自旋锁：尝试获取锁时，如果锁被占用，就循环尝试获取锁资源。
			适用于临界区很小的同步方法。如果执行时间较长，自旋锁在频繁的尝试获取锁，也是消耗CPU资源的。
				因此，需要设置自旋的次数，以防消耗太多CPU资源。
		2）适应性自旋锁
			jdk1.6之后，根据以往的表现，动态的增加或减少自旋的次数。
			如果之前自旋总能获取锁，则之后的自旋次数会增加；
			如果自选获取锁的几率总是很小，则之后会减少自旋次数。
		3）锁消除
			当JVM检测到不可能产生共享数据的竞争时，会自动消除锁。
			原理：逃逸分析
			如：方法的局部变量使用了Vector或StringBuffer等线程安全的工具
		4）锁粗化
			当发现连续多个加锁，解锁的动作时，加锁解锁会导致不必要的消耗性能，因此会将锁的范围扩大。
		5）偏向锁
			大部分时候，共享数据只被一个线程访问，不存在竞争，因此引入偏向锁。
			一旦线程第一次获取了锁对象，对象头信息里就会记录偏向锁（threadId），之后再次获取锁对象时可以避免CAS。
			流程：
				a.检测对象头中的Mark Word是否为可偏向状态；
				b.检测偏向ThreadId是否为当前线程id
					1）是，则不需CAS，执行代码块；
					2）不是，CAS竞争锁
						A.成功，修改对象头中的ThreadId；
						B.失败，说明存在竞争关系，如果达到全局安全点（此时间点没有正在执行的代码），
							则偏向锁升级为轻量级锁。对象头中的偏向id被替换为线程锁地址的指针。
								
			偏向锁的释放：存在竞争
		6）轻量级锁
			CAS
			a.线程进入同步代码块时，如果检查对象锁状态为无锁状态，则在当前线程的栈帧中建立Lock Record(锁记录)的空间
					用于从锁对象中copy对象头中的Mark Word；
			b.将对象头中的Mark Word拷贝到Lock Record中；
			c.使用CAS将对象头中Mark Word信息里的Lock Word(锁信息)更改为当前线程的Lock Record指针，
				将Lock Record里的owner指针指向Mark Word；
				A.成功，表示获取到对象锁，将对象头信息中的锁标记修改为"00"，表示轻量级锁。然后执行代码块；
				B.失败，检查对象头的Lock Word是否指向当前线程的Lock Record；
					1.是，则表示已经获取锁对象，执行代码块；
					2.否，继续CAS自旋，如果自旋结束仍未获取锁对象，则膨胀为重量级锁。
						对象头信息锁标记改为“10”，指向重量级锁的指针。当前线程和之后的线程都进入阻塞状态。
		7）重量级锁
		
		1.5之后
		偏向锁 ->      轻量级锁 ->      重量级锁
		   锁争用    CAS适应性自旋锁
三、Lock
	使用：
		需要手动的加锁，解锁：lock  unlock  
		可以被中断等待  ：lockInterruptibly可以被thread.interrupt()方法终端
		可以尝试获取锁： tryLock()  tryLock(Long time,TimeUnit unit)
		可以加条件锁：  Lock.newCondition()
			condition.await()  condition.signal();  condition.signalAll(); 
	实现原理：
		CAS+AQS
	AbstractQueuedSynchronizer 队列同步器
	属性：state 当前锁状态
		exclusiveOwnerThread 获取锁的当前线程  (AbstarctOwnerSynchronizer的属性)
		Node  队列
	
	线程进入Lock.lock()时，会尝试设置state=1
		a.如果设置成功，设置exclusiveOwnerThread为当前线程
		b.设置失败，表示已经有线程占有了该锁对象，则进入Node队列
		
四、AQS AbstractQueuedSynchronizer  抽象队列同步器
	CLH队列
	--待续
	
五、Mysql锁
	1、概述
		表锁：开销小，加锁快；容易出现冲突，并发低。
		行锁：开销大，加锁慢；不容易出现冲突，并发高。
		页面锁：介于表锁和行锁之间。
		MyISAM支持表锁，InnoDB支持行锁,也支持表锁。
	2、MyISAM锁
		表共享读锁和表独占写锁
		写锁：线程获取某表写锁后，自身可以对该表进行读，写操作；
				阻塞其他线程对该表的读和写操作；
		读锁：线程获取某表读锁后，自身可以对该表进行读操作，不能对该表进行写操作，也不能对其他表进行读，写操作；
				阻塞其他线程对该表的写操作，不会影响其他线程的读操作；
		


六、线程池
	1.


七、乐观锁和悲观锁


java主流锁体系
1、乐观锁、悲观锁
	悲观锁：认为自己在使用数据的时候一定有其他线程来修改数据，在获取数据时会先加锁，
		确保其他线程不被其他线程修改
		锁实现：synchronized、Lock
		适用场景：写操作较多，先加锁可以保证写操作时的数据正确
	乐观锁：认为自己在使用数据时，不会有其他线程来修改数据，所以不会添加锁。
		只是在更新数据的时候，去判断之前有没有其他线程更新了数据。
		锁实现：CAS算法，例如AtomicInteger
		使用场景：读操作较多，不加锁的特点能够使其读操作的性能大幅提升。
		
	CAS算法：Compare And Swap
		涉及比较的三个值：工作缓存中获取到的值 A
						主内存中当前的值 B
						修改后的值
		如果A和B值不一致，会自旋，重新获取主内存的值，再次比较；
		
		CAS的问题：
			1.ABA问题：A和B的值相等，但是B可能是其他线程已经修改后的值。
				解决：使用AtomicStampedReference,在变量前加版本号，每次更新时将版本号加1。
			2.循环时间长，开销大
			3.只能保证一个共享变量的原子操作。
				（AtmoicReference可以保证对象的原子性，将多个变量放在对象中）
		
		自适应自旋锁：jvm会根据之前自旋次数来决定之后的自旋次数。
		
		进程与线程的上下文切换，为什么消耗资源？ 
		线程没有cpu调度权，上下文切换时，需要先通知操作系统，操作系统来调度cpu时间片。
		cpu寄存器中会保存线程执行的中间变量，上下文切换时，cpu需要将寄存器中的信息保存在内存中；
		当时间片切回到该线程时，cpu需要将<中间变量>再从[内存]中加载到cpu寄存器中，
			需要将[线程栈]中<程序指令位置>也加载到cpu寄存器中。
			
		实例对象是怎么存储的？
		对象实例存在堆空间，对象的元数据存在方法区（永久代，元空间），对象的引用存在栈空间。
		  
2、读锁（共享锁）、写锁（排它锁）
3、自旋锁、非自旋锁
4、无锁、偏向锁、轻量级锁、重量级锁
5、分布式锁
6、区间锁（分段锁） java.util.concurrent
7、重入锁、非重入锁
8、公平锁、非公平锁

	
	