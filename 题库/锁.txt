1.乐观锁与悲观锁？实现？应用场景

2.synchronized的原理，jdk6对synchronized的优化
	
	一、作用
		1.原子性  确保线程互斥的访问同步代码
		2.可见性  保证共享变量的修改可以及时可见   java内存模型：工作内存-主内存
		3.有序性  一个解锁操作发生在下一个加锁操作之前
	二、用法
		synchronized可以把任意一个非null对象作为“锁”，jvm中叫对象监视器（Object Minoter）
		1.作用于方法上    锁定的是实例对象
		2.作用于静态方法上   锁定的是类对象
		3.作用于代码块上   锁定的是实例对象
	三、特性
		1、对象锁  作用于对象上 ，可实现对临界资源的同步互斥访问
		2、排它锁
		3、可重入性  线程持有锁之后，可同步访问同一对象或父类对象的同步方法，无需再获取锁
	四、同步原理
		1）同步代码块的同步
			对象监视器（Object Monitor）
			monitorenter：尝试获取monitor所有权
				1.如果monitor进入数为0，则进入monitor，将monitor进入者设置为1，成为monitor的owner；
				2.如果线程已经进入了monitor，只是重新进入，则进入者+1；
				3.如果其他线程已经占用了monitor，则进入阻塞状态。
			
			monitorexit：退出monitor
				monitor进入数-1，如果为0，则释放monitor的所有权
		
		2）同步方法的同步
			ACC_SYNCHRONIZED 标志位
			线程执行方法时，会检查方法的ACC_SYNCHRONIZED标识是否被设置，如果被设置了，
				执行线程会先获取monitor，在执行方法体，执行完之后释放monitor。
				
		Monitor记录的信息：
			count：进入Monitor的数量
			_EntryList:处于Blocking状态的线程
			_WaitingList:处于排队状态的线程
			_owner:当前所对象的拥有者
			1、当多个线程同时访问一段同步代码时，进入_EntryList集合，获取到Monitor的线程，
				进入_Owner区域,并把当前Monitor的owner设置为当前线程，count数+1；
			2、如果调用了wait方法，释放当前Monitor，owner为null，count-1，
				进入waitList并等待被唤醒；
			3、线程执行完毕，则释放Monitor，恢复count
		Monitor会在对象头里的Mark Word中被引用指向。
		
	五、synchronized的优化  （jdk1.6之后）
		锁主要存在四种状态：无锁、偏向锁、轻量级锁、重量级锁
			升级是单向的，不会出现锁的降级。
			jdk1.6中默认是开启偏向锁和轻量级锁的，可以使用-XX:-UseBiasedLocking禁用偏向锁。
		
		1）自旋锁
			使用原因：
				大部分的临界区是很小的，占用的时间很短，如果频繁的阻塞和唤醒，代价太大，因此引入自旋锁。
			自旋锁：尝试获取锁时，如果锁被占用，就循环尝试获取锁资源。
			适用于临界区很小的同步方法。如果执行时间较长，自旋锁在频繁的尝试获取锁，也是消耗CPU资源的。
				因此，需要设置自旋的次数，以防消耗太多CPU资源。
		2）适应性自旋锁
			jdk1.6之后，根据以往的表现，动态的增加或减少自旋的次数。
			如果之前自旋总能获取锁，则之后的自旋次数会增加；
			如果自选获取锁的几率总是很小，则之后会减少自旋次数。
		3）锁消除
			当JVM检测到不可能产生共享数据的竞争时，会自动消除锁。
			原理：逃逸分析
			如：方法的局部变量使用了Vector或StringBuffer等线程安全的工具
		4）锁粗化
			当发现连续多个加锁，解锁的动作时，加锁解锁会导致不必要的消耗性能，因此会将锁的范围扩大。
		5）偏向锁
			大部分时候，共享数据只被一个线程访问，不存在竞争，因此引入偏向锁。
			一旦线程第一次获取了锁对象，对象头信息里就会记录偏向锁（threadId），之后再次获取锁对象时可以避免CAS。
			流程：
				a.检测对象头中的Mark Word是否为可偏向状态；
				b.检测偏向ThreadId是否为当前线程id
					1）是，则不需CAS，执行代码块；
					2）不是，CAS竞争锁
						A.成功，修改对象头中的ThreadId；
						B.失败，说明存在竞争关系，如果达到全局安全点（此时间点没有正在执行的代码），
							则偏向锁升级为轻量级锁。对象头中的偏向id被替换为线程锁地址的指针。
								
			偏向锁的释放：存在竞争
		6）轻量级锁
			CAS
			a.线程进入同步代码块时，如果检查对象锁状态为无锁状态，则在当前线程的栈帧中建立Lock Record(锁记录)的空间
					用于从锁对象中copy对象头中的Mark Word；
			b.将对象头中的Mark Word拷贝到Lock Record中；
			c.使用CAS将对象头中Mark Word信息里的Lock Word(锁信息)更改为当前线程的Lock Record指针，
				将Lock Record里的owner指针指向Mark Word；
				A.成功，表示获取到对象锁，将对象头信息中的锁标记修改为"00"，表示轻量级锁。然后执行代码块；
				B.失败，检查对象头的Lock Word是否指向当前线程的Lock Record；
					1.是，则表示已经获取锁对象，执行代码块；
					2.否，继续CAS自旋，如果自旋结束仍未获取锁对象，则膨胀为重量级锁。
						对象头信息锁标记改为“10”，指向重量级锁的指针。当前线程和之后的线程都进入阻塞状态。
		7）重量级锁
		
三、Lock
	使用：
		需要手动的加锁，解锁：lock  unlock  
		可以被中断等待  ：lockInterruptibly可以被thread.interrupt()方法终端
		可以尝试获取锁： tryLock()  tryLock(Long time,TimeUnit unit)
		可以加条件锁：  Lock.newCondition()
			condition.await()  condition.signal();  condition.signalAll(); 
	实现原理：
		CAS+AQS
	AbstractQueueSynchronizer 队列同步器
	属性：state 当前锁状态
		exclusiveOwnerThread 获取锁的当前线程  (AbstarctOwnerSynchronizer的属性)
		Node  队列
	
	线程进入Lock.lock()时，会尝试设置state=1
		a.如果设置成功，设置exclusiveOwnerThread为当前线程
		b.设置失败，表示已经有线程占有了该锁对象，则进入Node队列
		
四、AQS AbstractQueuedSynchronizer